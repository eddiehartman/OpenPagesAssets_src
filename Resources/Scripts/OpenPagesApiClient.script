<?xml version="1.0" encoding="UTF-8"?><MetamergeConfig Cycle="3" UUID="0c129e84-afec-48a9-9cdd-8d3bf71385f0" created="Tue Aug 18 13:40:40 CEST 2020" createdBy="eddie" main="OpenPagesApiClient" modified="Tue Feb 16 17:40:55 CET 2021" modifiedBy="edbir" project="POC_MVP" version="7.1.1">
    <Script name="OpenPagesApiClient">
        <ModTime>1613493655302</ModTime>
        <parameter name="includeFiles"/>
        <parameter name="script"><![CDATA[//////////////////////////////////////////////////////////////////////////////
//
//  Licensed Materials - Property of IBM
//
//  5725-D51
//
//  (C) Copyright IBM Corporation 2017.  All Rights Reserved.
//
//  US Government Users Restricted Rights - Use, duplication or
//  disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
//
//////////////////////////////////////////////////////////////////////////////
var OpenPagesApiClient = function () {
	return {
		initialized : false,
		requestEntry : null,
		cookies : null,
		isoDateMask1 : null,
		isoDateMask2 : null,
		message : {
			"Required parameter not set" : "Required parameter not set",
			"Response from" : "Response from",
			"Request to" : "Request to",
			"Error from" : "Error from",
			"You must restart the SDI server in order for the imported certificate to be trusted." : "You must restart the SDI server in order for the imported certificate to be trusted.",
			"Unable to parse JSON return from" : "Unable to parse JSON return from",
			"Invalid format for URL parameter" : "Invalid format for URL parameter",
			"No field definitions returned for GRC object type" : "No field definitions returned for GRC object type",
			"GRC Object type" : "GRC Object type",
			"has no field defintion for attribute" : "has no field defintion for attribute",
			"The following field is readOnly and cannot be written to" : "The following field is readOnly and cannot be written to",
			"No types returned by OpenPages" : "No types returned by OpenPages",
			"The following fields are readOnly and cannot be written" : "The following fields are readOnly and cannot be written",
			"The following fields are required" : "The following fields are required",
			"Unable to parse DATE_TYPE value for" : "Unable to parse DATE_TYPE value for"
		},
		grcSystemFieldNames : ["name", "description", "primaryParentId", "typeDefinitionId", "parentFolderId"],
		grcSystemFieldTypes : ["String", "String", "Integer (Id)", "Integer (Id)", "Integer (Id)" ],
		schemaType : {
			"DATE_TYPE" : "Date",
			"INTEGER_TYPE" : "Integer",
			"ID_TYPE" : "Integer (Id)",
			"STRING_TYPE" : "String (limited to 4000 characters)",
			"MEDIUM_STRING_TYPE" : "Medium size String (limited to 32000 characters)",
			"LARGE_STRING_TYPE" : "Large size String (limited to configured maximum)",
			"ENUM_TYPE" : "String",
			"MULTI_VALUE_ENUM" : "String (multi-valued)",
			"CURRENCY_TYPE" : "Number (value in default currency)",
			"BOOLEAN_TYPE" : "Boolean (true or false)",
			"FLOAT_TYPE" : "Floating point decimal"
		},
		state : null,
		http : null,
		mailer : null,
		feedProps : null,
		resultSet : null,
		json : null,
		resourceCache : null,
		requirementCache : null,
		initialize : function() {
			return this;
		},
		initializeConnector : function (args) {
			if (this.initialized) {
				this.terminate();
			}
			this.json = new JsonUtil();
			this.requestEntry = system.newEntry();
			this.cookies = system.newEntry();
			this.isoDateMask1 = "yyyy-MM-dd'T'HH:mm:ss.SSZ";
			this.isoDateMask2 = "yyyy-MM-dd'T'HH:mm:ss.SSSZ";
			this.http = system.getConnector("ibmdi.HTTPClient");
			this.http.initialize(null);
			this.mailer = new OPMailProvider().initialize({
				client : this
			});
			this.feedProps = new OPClientFeedProps().initialize({
				client : this
			});
			this.resultSet = new OPResultSet().initialize({
				client : this
			});
			this.state = new OPClientState().initialize({
				client : this,
				opConnectSettings : args.opConnectSettings
			});
			this.initialized = true;
			this.state.initializeOPServerConnection();
			return this;
		},
		terminate : function() {
			this.initialized = false;
			this.http.terminate();
		},
		getGrcObject : function(args) {
			var resp = this.makeRequest({
				verb : "GET",
				ctype : "application/json;charset=utf-8",
				url : this.formatFindObjectQuery(args) + "&caseInsensitive=true"
			});
			return this.grcObjectToEntry(resp);
		},
		executeGrcObjectQuery : function(queryPath, ignoreCache) {
			return this.makeRequest({
				ignoreCache : ignoreCache,
				verb : "GET",
				ctype : "application/json;charset=utf-8",
				url : "/query?q=" + queryPath.replace(" ", "+") + "&caseInsensitive=true",
				where : "executeGrcObjectSetQuery"
			});
		},
		executeGrcObjectSetQuery : function(queryPath) {
			this.resultSet.getResultSet({
				verb : "GET",
				ctype : "application/json;charset=utf-8",
				url : "/query?q=" + queryPath.replace(" ", "+") + "&caseInsensitive=true",
				where : "executeGrcObjectSetQuery"
			});
		},
		getGrcObjectContents : function(resourceId) {
			try {
				return this.makeRequest({
					verb : "GET",
					url : "/contents/" + resourceId,
					where : "getGrcObjectContents"
				});
			} catch (e) {
				if (this.state.isDebug()) {
					this.logDebug("Exception occurred; details:\n" + e);
				}
			}
		},
		getObjectParentAssociations : function(objectType) {
			try {
				return this.makeRequest({
					"verb" : "GET",
					url : "/types/" + objectType + "/associations/parents",
					where : "getObjectParentAssociations",
					ignoreCache : true
				});
			} catch (e) {
				if (this.state.isDebug())
					this.logmsg("DEBUG", "Exception occurred; details:\n" + e);
			}
		},
		/**
		 * Call to OpenPages API for a single entity using the provided path
		 * @param grcEntityPath - a resource path for a single OpenPages entity
		 * @returns {*}
		 */
		executeGrcEntityPath : function(grcEntityPath) {
			return this.makeRequest({
				verb : "GET",
				ctype : "application/json;charset=utf-8",
				url : grcEntityPath,
				where : "executeGrcEntityPath"
			});
		},
		executeGrcObjectSetPath : function(grcObjectSetPath) {
			this.resultSet.getResultSet({
				verb : "GET",
				ctype : "application/json;charset=utf-8",
				url : grcObjectSetPath,
				where : "executeGrcObjectSetPath"
			});
		},
		/**
		 * Creates a new grc object.
		 *
		 * @param grcObj - A javascript object whose properties are the field names.  The properties of an object type
		 * 				   can be retrieved from the OP Rest API via this call:
		 * 				   http://<opserver>:<opport>/grc/api/types/<Type Name>, where <Type Name> is for example:
		 * 				   Submandate, Mandate, Requirement, etc.  Want to know what all the valid types are?  Leave
		 * 				   out the type name in the above example and you get all types in return.
		 */
		postGrcObject : function(grcObj) {
			var grcObjectResponse = this.makeRequest({
				"verb" : "POST",
				"url" : "/contents",
				"ctype" : "application/json;charset=utf-8",
				"where" : "putEntry",
				"body" : this.makeJson(grcObj)
			});
			var statusMsg = "Added GRC object " + grcObj.name;
			var processingStep = this.getCurrentWorkValue("processingStep");
			if (processingStep) {
				this.logmsg("INFO", processingStep + ": " + statusMsg);
			} else {
				this.logmsg("INFO", statusMsg);
			}
			return grcObjectResponse;
		},
		/**
		 * Updates an existing grc object
		 *
		 * @param grcObj - a javascript object whose properties are the field names of the object to update
		 * @param resourceID - the object resource id to update; FYI: the object can be found via the OP Rest Api
		 * 					   call http://<opserver>:<opport>/grc/api/contents/<Resource ID>.
		 */
		putGrcObject : function(grcObj, resourceID) {
			this.clearResourceReferencesFromCache(resourceID);
			// this.logmsg("INFO", "Putting (updating) grcObject: " + this.makeJson(grcObj));
			this.makeRequest({
				verb : "PUT",
				url : "/contents/" + resourceID,
				ctype : "application/json;charset=utf-8",
				where : "modEntry",
				body : this.makeJson(grcObj)
			});
			var statusMsg = "Updated GRC object " + grcObj.name + " with resource id " + resourceID;
			var processingStep = this.getCurrentWorkValue("processingStep");
			if (processingStep) {
				this.logmsg("INFO", processingStep + ": " + statusMsg);
			} else {
				this.logmsg("INFO", statusMsg);
			}
		},
		/**
		 * Sets the child resource as a secondary child of the parent resource.
		 *
		 * @param parentResourceId - the grc resource id of the parent grc object
		 * @param childResourceId - the grc resource id of the child grc object
		 */
		setSecondaryParentAssociationFromResourceIds : function(parentResourceId, childResourceId) {
			var parentResource = this.getGrcObjectContents(parentResourceId);
			if (! parentResource) {
				throw "Parent resource " + parentResourceId + " not found.  Secondary parent association cannot be made";
			}
			var childResource = this.getGrcObjectContents(childResourceId);
			if (! childResource) {
				throw "Child resource " + childResourceId + " not found.  Secondary parent association cannot be made";
			}
			this.setSecondaryParentAssociation({
				parentResourceId : parentResourceId,
				parentTypeId : parentResource.typeDefinitionId,
				parentPath : parentResource.path,
				childResourceId : childResourceId,
				childTypeId : childResource.typeDefinitionId
			});
		},
		/**
		 * Sets the child resource as a secondary child of the parent resource.
		 *
		 * @param args - parentResourceId 	- the Resource Id of the parent grc object
		 * 				 parentTypeId	  	- the resource type id
		 * 				 parentPath 		- the path of the parent resource
		 * 				 childResourceId	- the Resource Id of the child grc object
		 * 				 childTypeId		- the type id of the child grc object
		 */
		setSecondaryParentAssociation : function(args) {
			//
			// Make sure the secondary parent relationship isn't already set
			//
			var existingParents = this.getSecondaryParentAssociations(args.childResourceId);
			if (! existingParents || ! existingParents.length || ! this.findPropertyInObjectList(existingParents, "id", args.parentResourceId)) {
				this.makeRequest({
					verb: "POST",
					url: "/contents/" + args.childResourceId + "/associations/parents",
					ctype: "application/json;charset=utf-8",
					where: "setSecondaryParentAssociation",
					body: toJson([{
						id: args.parentResourceId,
						typeDefinitionId: args.parentTypeId,
						path: args.parentPath,
						associationDefinitionId: args.childTypeId,
						type: "PARENT"
					}])
				});
			}
		},
		getSecondaryParentAssociations : function(childResourceId) {
			return this.makeRequest({
				verb : "GET",
				url : "/contents/" + childResourceId + "/associations/parents",
				ctype : "application/json;charset=utf-8",
				where : "getSecondaryParentAssocations",
				ignoreCache : true
			});
		},
		//
		// Gets the resource id for a particular entity
		//
		getMandateByUcfId : function(ucfId) {
			var resp = this.makeRequest({
				verb : "GET",
				ctype : "application/json;charset=utf-8",
				grcObjectType : "Mandate",
				fields : "*",
				keyField : "UCF-Mand:UCFID",
				keyValue : ucfId
			});
			return this.grcObjectToEntry(resp);
		},
		//
		// Gets the resource id for a particular entity
		//
		getSubMandateByUcfId : function(ucfId) {
			var resp = this.makeRequest({
				verb : "GET",
				ctype : "application/json;charset=utf-8",
				grcObjectType : "Submandate",
				fields : "*",
				keyField : "UCF-SubMand:UCF ID",
				keyValue : ucfId
			});
			return this.grcObjectToEntry(resp);
		},
		//
		// Find a grc object by a specified key field
		//
		// args:
		// 	grcObjectName - The object name, eg "Mandate"
		// 	fields - a comma delimited list of fields to query; defaults to "*" which indicates to get all fields
		// 	keyField - the name of the field that serves as the key, eg "UCF-Mand:UCFID"
		// 	keyValue - the value of the key field to search on, eg "0000010"
		//
		formatFindObjectQuery : function(args) {
			return this.formatQueryPath({
				grcObjectType : args.grcObjectType,
				fields : (args.fields ? args.fields : null),
				whereClause : "[" + args.keyField + "] = '" + args.keyValue + "'"
			})
		},
		//
		// args:
		//		grcObjectType - the grc object type name to look up
		//		fields - a comma delimited list of fields to query; defaults to "*" which indicates to get all fields
		//		whereClause - the where clause to narrow the result set
		//
		formatQueryPath : function(args) {
			var queryPath = "SELECT " +
				(args.fields ? args.fields : "*" ) +
				" from [" +
				args.grcObjectType +
				"]" +
				(args.whereClause ? (" WHERE " + args.whereClause) : "");
			return "/query?q=" + queryPath.replace(" ", "+");
			// java.net.URLEncoder.encode(queryPath.replace(" ", "+"), "UTF-8");
		},
		selectEntries : function() {
		},
		selectConnectorEntries : function(args) {
			if (! this.initialized) {
				this.throwNotInitializedError();
			}
			var urlPath = "/query?q=";
			var selectClause, whereClause, query;
			var url;
			if (args) {
				urlPath = (args.urlPath) ? args.urlPath : urlPath;
				selectClause = args.selectClause;
				whereClause = args.whereClause;
			}
			if (! selectClause) {
				selectClause = "SELECT * from [" + this.state.getGrcObjectType() + "]";
				if (this.state.hasQuery()) {
					selectClause = this.state.getQuery();
				}
			}
			url = urlPath;
			if (url.equalsIgnoreCase("/query?q=")) {
				query = selectClause;
				if (whereClause && query.indexOf(" WHERE ") < 0) {
					query += whereClause;
				}
				url += java.net.URLEncoder.encode(query, "UTF-8");
			}
			this.resultSet.getResultSet({
				verb : "GET",
				url : url,
				ctype : "application/json;charset=utf-8",
				where : "selectConnectorEntries"
			});
		},
		ensureInitialized : function(args) {
			if (! this.initialized) {
				this.initializeConnector(args);
				this.selectConnectorEntries();
			}
		},
		getNextEntry : function() {
			this.ensureInitialized();
			var e = this.resultSet.next();
			if (e) {
				entry.merge(e);
				result.setStatus(1);
			} else {
				result.setStatus(0);
			}
			return entry;
		},
		/**
		 * Add a new grcObject to OpenPages
		 */
		putEntry : function() {
			if (! this.initialized) {
				this.initializeConnector();
			}
			var grcObj = this.entryToGrcObject(entry, true /* creating new */);
			var objName = (! grcObj.name || grcObj.name === "" ? "<no name provided>"
				: grcObj.name);
			if (this.state.isDebug())
				this.logmsg("--->\n" + this.makeJson(grcObj));
			var grcObjectResponse = this.postGrcObject(grcObj);
			//
			// todo: Figure out a better way to perform conditional logic when putting grc objects that doesn't involve
			// switching in a generic method common to all assembly lines that put grc object data.
			// For now, this is an expedience due to time constraints.
			//
			if (this.state.getGrcObjectType() == "Requirement") {
				//
				// Cache the requirement now as it could turn up again in the same assembly line because it can be
				// shared across authority documents and even citations in the same authority document.
				//
				this.cacheRequirement(objName, grcObjectResponse);
				this.setSecondaryRequirementParentAssociations(this.getResourceIDFromGrcObject(grcObjectResponse));
			}
		},
		setSecondaryRequirementParentAssociations : function(requirementResourceID) {
			//
			// Assembly line collects these citation ids in preparation for this process to pick up and set
			// as secondary parents
			//
			var secondaryParentCitationIDs = entry["citations"];
			if (secondaryParentCitationIDs) {
				var numCitations = secondaryParentCitationIDs.size();
				for (var i=0; i < numCitations; i++) {
					var secondaryParentCitationID = secondaryParentCitationIDs[i];
					var submandateName = "UCF-CIT-" + new java.text.DecimalFormat("0000000").format(
							parseInt(secondaryParentCitationID , 10));
					try {
						var submandateObj = this.executeGrcObjectQuery(
							"SELECT [Resource ID] FROM [Submandate] where [Name] = '" + submandateName + "'");
						var submandateResourceID = this.getResourceIDFromGrcObject(submandateObj);
						if (submandateResourceID) {
							this.setSecondaryParentAssociationFromResourceIds(submandateResourceID, requirementResourceID);
						}
					} catch (e) {
						this.logmsg("ERROR", "Failed to establish seconary parentage from Requirement " +
							requirementResourceID + " to Submandate " + submandateName);
					}
				}
			}
		},
		/**
		 * Extract the named field value from the grcObject.
		 *
		 * @param grcObject - a grc object that has either been queried or lookup up in some fashion from OpenPages
		 * @param fieldPropKey - the name of the property key to search on
		 * @param fieldPropValue - the value of the field identified by fieldPropKey to search for
		 *
         * @returns {*}
         */
		getFieldValueFromGrcObject : function(grcObject, fieldPropKey, fieldPropValue) {
			if (grcObject.rows && grcObject.rows.length) {
				grcObject = grcObject.rows[0];
			}
			if (grcObject && grcObject.fields && grcObject.fields.field) {
				var field = this.findPropertyInObjectList(grcObject.fields.field, fieldPropKey, fieldPropValue);
				return field && field.value;
			}
			return null;
		},
		/**
		 * Find the Resource ID value from a grcObject
		 *
		 * @param grcObject - a grc object that has either been queried or lookup up in some fashion from OpenPages
		 *
         * @returns {*}
         */
		getResourceIDFromGrcObject : function(grcObject) {
			return this.getFieldValueFromGrcObject(grcObject, "name", "Resource ID");
		},
		/**
		 * Finds an object in a list of objects that has a property (identified by propKey) with the value
		 * specified by propValue
		 *
		 * @param objectList - the object list to search
		 * @param propKey - the name of the object property to search on
		 * @param propValue - the value the object property must have to identify the object to return
		 *
         * @returns the object if found, null otherwise
         */
		findPropertyInObjectList : function(objectList, propKey, propValue) {
			for (var i=0; i < objectList.length; i++) {
				var obj = objectList[i];
				if (obj[propKey] && obj[propKey] === propValue) {
					return obj;
				}
			}
		},
		modEntry : function() {
			if (! this.initialized) {
				this.initializeConnector();
			}
			var grcObjectResourceId = this.state.current.getString("Resource ID");
			var existingGrcObject = null;
			var objName = null;
			if (this.state.getGrcObjectType() == "Requirement") {
				objName = entry["name"];
				if (objName && objName.getValue) {
					existingGrcObject = this.getCachedRequirement(objName.getValue());
				}
			}
			//
			// Only update an object that has not already been updated
			//
			if (! existingGrcObject) {
				var grcObj = this.entryToGrcObject(entry, false /* modifying existing */);
				if (this.state.isDebug()) {
					this.logmsg("--->\n" + this.makeJson(grcObj));
				}
				this.putGrcObject(grcObj, grcObjectResourceId);
			}
			if (this.state.getGrcObjectType() == "Requirement") {
				this.setSecondaryRequirementParentAssociations(grcObjectResourceId);
			}
		},
		getNameFromSearchCriteria : function() {
			var critList = search.getCriteria();
			for (var crit in critList) {
				if (crit.name === "Name") {
					return crit.value;
				}
			}
			return null;
		},
		findEntry : function() {
			if (! this.initialized) {
				this.initializeConnector();
			}
			//
			// If this is a requirement object then first look in cache for the requirement by name.
			//
			if (this.state.getGrcObjectType() == "Requirement") {
				var requirementName = this.getNameFromSearchCriteria();
				if (requirementName) {
					var cachedRequirement = this.getCachedRequirement(requirementName);
					if (cachedRequirement) {
						result.setStatus(1);
						var reqEntry = this.grcObjectToEntry(cachedRequirement);
						this.state.setCurrent(reqEntry);
						return reqEntry;
					}
				}
			}
			var res = this.getGrcWhereClause(search);
			this.state.setCurrent(null);
			this.feedProps.clear(); // clear out the feed props for each new entry
			this.selectConnectorEntries({
				urlPath : res.path,
				whereClause : res.where,
				selectClause : res.query
			});
			if (this.resultSet.size() == 1) {
				var e = this.resultSet.next();
				result.setStatus(1);
				this.state.setCurrent(e);
				return e;
			} else if (this.resultSet.size() > 1) {
				while (this.resultSet.hasNext()) {
					connector.addFindEntry(this.resultSet.next());
				}
				result.setStatus(1);
			} else {
				result.setStatus(0);
			}
		},
		deleteEntry : function() {
			if (! this.initialized) {
				this.initializeConnector();
			}
			try {
				//noinspection JSPotentiallyInvalidUsageOfThis
				return this.makeRequest({
					"verb" : "DELETE",
					"url" : "/contents/" + this.state.current.getString("Resource ID"),
					"ctype" : "application/json;charset=utf-8",
					"where" : "deleteEntry"
				});
			} catch (ex) {
				this.logmsg("ERROR",
					"Unable to delete existing object; an exception occured in the OpenPages server: " + ex);
			}
		},
		querySchema : function(objectType) {
			var fieldDefs = this.state.getFieldDefinitions(objectType || this.state.getGrcObjectType());
			var keys = fieldDefs.keySet().toArray();
			java.util.Arrays.sort(keys);
			for (var key in keys) {
				list.add(this.newSchemaEntry(key, fieldDefs));
			}
			for (var i = this.grcSystemFieldNames.length - 1; i > 0; i--) {
				list.add(this.newSchemaEntry(this.grcSystemFieldNames[i], this.grcSystemFieldTypes[i]));
			}
			list.add(this.newSchemaEntry("$grcObject", "JavaScript Object"));
			list.add(this.newSchemaEntry("$grcObjectType", "String"));
			list.add(this.newSchemaEntry("$grcObjectJSON", "JSON"));
			result.setStatus(1);
		},
		newSchemaEntry : function(key, fieldDefs) {
			var e = new com.ibm.di.entry.Entry();
			if (typeof fieldDefs === "string" || typeof fieldDefs[key] === "string") {
				e.addAttributeValue("name", key);
				e.addAttributeValue("syntax", fieldDefs);
			} else {
				e.addAttributeValue("name", fieldDefs[key].name);
				e.addAttributeValue("syntax", this.getSchemaType(fieldDefs, key));
			}
			return e;
		},
		getGrcWhereClause : function(search) {
			var where = "";
			var path = null;
			var query = null;
			var critList = search.getCriteria();
			var type = this.state.getGrcObjectType();
			var boolOp = "AND";
			if (search.getType() == search.SEARCH_OR) {
				boolOp = "OR";
			}
			for (var crit in critList) {
				var fieldDef = this.state.getFieldDefinition(crit.name);
				if (! fieldDef) {
					throw "The link criteria of the OpenPages connector specifies a field name (" + crit.name + ") that does not belong " +
					"to the chosen OpenPages object type (" + type + ").  Either the link criteria or the chosen OpenPages object " +
					"has changed and is out of sync with the other.  Check both settings and try again.";
				}
				if ("Resource ID".equalsIgnoreCase(fieldDef.name) &&
					crit.match == search.EXACT && search.getType() == search.SEARCH_AND) {
					path = "contents/" + crit.value;
					query = null;
					where = null;
					break;
				}
				where += (where.length === 0) ? "" : " " + boolOp + " ";
				where += "[" + fieldDef.name + "]";
				where += this.getGrcClause(crit, fieldDef);
			}
			return {
				where : " WHERE " + where,
				path : path,
				query : query
			};
		},
		getGrcClause : function(criteria, fieldDef) {
			var match = criteria.match;
			var value = criteria.value;
			if (!"INTEGER_TYPE".equals(fieldDef.dataType) && !"CURRENCY_TYPE".equals(fieldDef.dataType)) {
				value = "'" + criteria.value + "'";
			}
			if (match == com.ibm.di.server.SearchCriteria.EXACT || match == com.ibm.di.server.SearchCriteria.EXCACT) {
				return " = " + value;
			} else if (match == com.ibm.di.server.SearchCriteria.FINAL_STRING) {
				return " LIKE '%" + criteria.value + "'";
			} else if (match == com.ibm.di.server.SearchCriteria.GREATER_THAN) {
				return " > " + value;
			} else if (match == com.ibm.di.server.SearchCriteria.GREATER_THAN_OR_EQUAL) {
				return " >= " + value;
			} else if (match == com.ibm.di.server.SearchCriteria.INITIAL_STRING) {
				return " LIKE '" + criteria.value + "%'";
			} else if (match == com.ibm.di.server.SearchCriteria.LESS_THAN) {
				return " < " + value;
			} else if (match == com.ibm.di.server.SearchCriteria.LESS_THAN_OR_EQUAL) {
				return " <= " + value;
			} else if (match == com.ibm.di.server.SearchCriteria.SUBSTRING) {
				return " LIKE '%" + criteria.value + "%'";
			} else {
				throw "Unknown match type: " + match;
			}
		},
		getSchemaType : function(fieldDefs, key) {
			var type = "?undefined " + key + "?";
			var fieldDef = fieldDefs[key];
			if (typeof fieldDef !== "undefined" || fieldDef !== null) {
				var fieldType = this.schemaType[fieldDef.dataType];
				if (fieldType !== null) {
					type = fieldType;
					if ("true".equalsIgnoreCase(fieldDef.readOnly)) {
						type += " (read only)";
					} else if ("true".equalsIgnoreCase(fieldDef.required)) {
						type += " (required)";
					}
				}
			}
			return type;
		},
		entryToGrcObject : function(entry, creatingNew) {
			if (typeof creatingNew === "undefined") {
				creatingNew = true;
			}
			// var grcObj = entry.getObject("$grcObject");
			// Place holder for future use (ucf_integration_control)
			// var grcObjType = entry.getObject("$grcObjectType");
			// if (grcObjType) {
			// 	this.state.setGrcObjectType(grcObjType);
			// 	var thisType = this.state.getTypeByName(grcObjType);
			// 	if (thisType) {
			// 		this.state.setGrcObjectTypeId(thisType.id);
			// 	}
			// }
			var grcObj = {
				fields : {
					field : []
				}
			};
			var fieldDefs = this.state.getFieldDefinitions(entry);
			var templates = this.state.getTemplate(entry);
			var objectType = fieldDefs.get("$grcObjectType");
			var readOnly = [];
			var required = [];
			grcObj.typeDefinitionId = this.state.getTypeByName(objectType).id;
			//
			// It is possible that the system field value for primaryParentId may not be specified.
			// If it is it will be used. If it is not, there may be feed-provided values for
			// "parentType" and "parentLocation" that can be used to derive the primaryParentId.
			// Obtain the static (or dynamically derived) value of the primaryParentId from the
			// feed now so that addGrcSystemField() can use the proper value.
			//
			this.feedProps.obtainPrimaryParentIdFromFeed(entry);
			var i, length;
			for (i = 0, length = this.grcSystemFieldNames.length; i < length; i++) {
				this.addGrcSystemField(grcObj, this.grcSystemFieldNames[i], entry);
			}
			var keys = templates.keySet().toArray();
			java.util.Arrays.sort(keys);
			for (var key in keys) {
				if (key.startsWith("$")) {
					continue;
				}
				var fieldDef = fieldDefs.get(key);
				var att = entry.getAttribute(fieldDef.name);
				if (fieldDef.required && att === null && creatingNew) {
					required.push(fieldDef);
				} else if (fieldDef.readOnly && att !== null) {
					readOnly.push(fieldDef);
				} else if (att !== null) {
					this.addGrcField(grcObj, att, fieldDef);
				}
			}
			var fields;
			if (required.length > 0) {
				fields = "";
				for (i = 0; i < readOnly.length; i++) {
					fields += (fields.length === 0 ? "" : ", ") + readOnly[i].name;
				}
				this.throwException(this.message["The following fields are required"] + ": " + fields);
			}
			if (readOnly.length > 0) {
				fields = "";
				for (i = 0; i < readOnly.length; i++) {
					fields += (fields.length === 0 ? "" : ", ") + readOnly[i].name;
				}
				this.logmsg(
					"WARN",
					this.message["The following fields are readOnly and cannot be written"] + ": " + fields);
			}
			// var ensureFieldValues = [
			// 	{from : "primaryParentId", to : "primaryParentId"},
			// 	{from : "name", to : "Name"},
			// 	{from : "reference", to : "Description"}
			// ];
			//
			// for (i=0; i < ensureFieldValues.length; i++) {
			// 	var field = ensureFieldValues[i];
			// 	if (! grcObj[field.to] && task.getCurrentWork()[field.from]) {
			// 		grcObj[field.to] = task.getCurrentWork()[field.from];
			// 	}
			// }
			return grcObj;
		},
		// This function is for use when setting an entry's primaryParentId
		setGrcPrimaryParentIdFromFeedPropsOrDefault : function(grcObj, name) {
			// If a valid primaryParentId was included in the feed for this entry then
			// use it
			if (this.feedProps.staticPrimaryParentId !== null) {
				grcObj[name] = this.feedProps.staticPrimaryParentId;
				// this.logmsg("INFO", "Using the static primaryParentId value '" + grcObj[name]+ "' supplied in the feed.");
			}
			// otherwise if a primaryParentId was derived from the feed properties then
			// use it
			else if (this.feedProps.derivedPrimaryParentId !== null) {
				grcObj[name] = this.feedProps.derivedPrimaryParentId;
				// this.logmsg("INFO", "Using the primaryParentId value '" + grcObj[name] +
				//    "' derived from the feed's parentType and parentLocation values.");
			}
			// otherwise use the default parent object ID (if any)
			else {
				var defaultPrimaryParentObjectId = this.state.getDefaultPrimaryParentObjectId();
				if (defaultPrimaryParentObjectId !== null) {
					grcObj[name] = defaultPrimaryParentObjectId;
					this.logmsg(
						"INFO",
						"A primaryParentId was not supplied in or derived from the feed; using the default primaryParentId value '" +
						defaultPrimaryParentObjectId +
						"' derived from the op_parentType and op_parentLoc properties. ");
				} else {
					this.logmsg("WARN",
						"A primaryParentId was not supplied in or derived from the feed, and a default primaryParentId is not defined.");
				}
			}
		},
		getCurrentWorkValue : function(key) {
			try {
				return task && task.getCurrentWork() ? task.getCurrentWork()[key] : null;
			} catch (e) {
				return "";
			}
		},
		getCurrentWorkValueString : function(key, required) {
			var value = this.getCurrentWorkValue(key);
			if (value && value.getValue) {
				value = value.getValue();
			}
			if (required && typeof value === "undefined") {
				throw "Required work property " + key + " not found.";
			}
			return value;
		},
		addGrcSystemField : function(grcObj, name, entry) {
			if ("typeDefinitionId".equalsIgnoreCase(name)) {
				grcObj[name] = this.getCurrentWorkValue("grcObjectTypeId");
			} else if ("primaryParentId".equalsIgnoreCase(name)) {
				grcObj["primaryParentId"] = this.getCurrentWorkValue("primaryParentId");
			} else {
				var att = entry[name];
				if (att) {
					// no special handling needed for this field, just set it
					grcObj[name] = att.getValue();
				}
			}
		},
		truncateStringForGrcField : function(stringValue, maxAllowedLength) {
			if (stringValue) {
				if (stringValue.length > maxAllowedLength) {
					stringValue = stringValue.substr(0, maxAllowedLength-50) + "...";
				}
			}
			return stringValue;
		},
		addGrcField : function(grcObj, att, fieldDef) {
			var grcField = {
				dataType : fieldDef.dataType,
				id : fieldDef.id,
				name : fieldDef.name
			};
			var inError = [];
			var attValue = null;
			var field = this.getResultObjectFields(grcObj);
			var addedValue = false;
			var message = "";
			if (this.state.isDebug())
				this.logmsg("DEBUG", "--> Attempting to add " + att.toString() + "   field: " + fieldDef.id);
			if (att !== null && att.size() > 0) {
				attValue = att.getValue(0);
			}
			var value;
			if (attValue !== null) {
				try {
					switch (fieldDef.dataType) {
						case "STRING_TYPE": // string length limited to 4000 chars
							var truncatedStr = this.truncateStringForGrcField(attValue, 4000);
							grcField.value = truncatedStr;
							addedValue = true;
							break;
						case "MEDIUM_STRING_TYPE": // string length limited to 32000 chars
							truncatedStr = this.truncateStringForGrcField(attValue, 32000);
							grcField.value = truncatedStr;
							addedValue = true;
							grcField.dataType = "STRING_TYPE";// nan - OP server doesn't
							// recognize
							// MEDIUM_STRING_TYPE
							break;
						case "LARGE_STRING_TYPE": // string length limited to OP registry
							// setting for largeStringMaxSize
							truncatedStr = this.truncateStringForGrcField(attValue,
								this.state.largeStringMaxSize);
							grcField.value = truncatedStr;
							addedValue = true;
							break;
						case "ID_TYPE":
						case "BOOLEAN_TYPE":
						case "FLOAT_TYPE":
							grcField.value = attValue;
							addedValue = true;
							break;
						case "INTEGER_TYPE":
							grcField.value = attValue;
							addedValue = true;
							break;
						case "ENUM_TYPE":
							value = this.enumValue(attValue, fieldDef);
							if (value !== null) {
								grcField.enumValue = value;
								addedValue = true;
							} else {
								message = "Attempt to add value of '" + attValue +
									"' to enumerated field definition '" +
									fieldDef.name +
									"' was not allowed to object type '" +
									this.state.getGrcObjectType() +
									"'." +
									" The assembly line mapping will need to be modified.";
								this.logmsg("WARN", message);
								this.mailer.sendEmailNotification(message);
							}
							break;
						case "MULTI_VALUE_ENUM":
							grcField.enumValue = [];
							for (var i = 0; i < att.size(); i++) {
								value = this.enumValue(att.getValue(i), fieldDef);
								if (value !== null) {
									grcField.enumValue.push(value);
									addedValue = true;
								} else {
									message = "Attempt to add value of '" + attValue +
										"' to multi-enumerated field definition '" +
										fieldDef.name +
										"' was not allowed to object type '" +
										this.state.getGrcObjectType() +
										"'." +
										" The assembly line mapping will need to be modified.";
									this.logmsg("WARN", message);
									this.mailer.sendEmailNotification(message);
								}
							}
							break;
						case "DATE_TYPE":
							var dateValue = attValue instanceof java.util.Date ? attValue : this.parseDateValue(attValue);
							if (dateValue !== null) {
								// "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'" // works but TZ is not
								// accurate
								// TDI 7.1.1 uses Java 6, so we cannot use format string
								// "yyyy-MM-dd'T'HH:mm:ss.SSSXXX"
								// (which *is* supported in Java 7 and newer). So, we are
								// using format string
								// "yyyy-MM-dd'T'HH:mm:ss.SSSZ" and are manually inserting
								// the colon into place at the
								// end of the string in the 4 digits that follow the last
								// "-" or "+" character, and
								// (if present) we remove the ':' directly in front of the
								// 'T'.
								// Example: convert 2013-10-07T07:36:13.000-0400 to
								// 2013-10-07T07:36:13.000-04:00
								// Example: convert 2013-10-07:T07:36:13.000-0400 to
								// 2013-10-07T07:36:13.000-04:00
								var sdf = new java.text.SimpleDateFormat(
									"yyyy-MM-dd'T'HH:mm:ss.SSSZ");
								var timeDate = sdf.format(dateValue);
								timeDate = timeDate.replace(":T", "T");
								var timeDateStr = new java.lang.String(timeDate);
								var insertColonPos = timeDateStr.length - 2;
								var firstPart = timeDateStr.substring(0, insertColonPos);
								var lastPart = timeDateStr.substring(insertColonPos, timeDateStr.length);
								grcField.value = new java.lang.String(firstPart + ":" + lastPart);
								addedValue = true;
							}
							break;
						case "CURRENCY_TYPE":
							// Mapping format required for a currency value in the feed must
							// follow this example:
							// "123.45|AUD"
							// If no ISO code is supplied then the OP Base ISO code is used.
							var valueStr = new java.lang.String(attValue.trim());
							if (valueStr === "") {
								break;
							}
							var separatorIndex = valueStr.indexOf("|");
							var amount = "";
							var doubleVal = null;
							var isoCode = "";
							// parse out the amount and the ISO code from the provided
							// attValue string
							if (separatorIndex !== -1) {
								amount = valueStr.substring(0, separatorIndex).trim();
								isoCode = valueStr.substring(separatorIndex + 1).trim();
							} else {
								amount = valueStr.trim();
							}
							// ensure that the amount is a valid double value
							try {
								doubleVal = java.lang.Double.parseDouble(amount);
							} catch (ex) {
								this.logmsg(
									"ERROR",
									"Detected missing or invalid amount '" +
									amount +
									"' in the value " +
									"specified from the feed for CURRENCY_TYPE field '" +
									fieldDef.name +
									"'. Skipping this currency value.");
								break;
							}
							// ensure that the ISO code is not empty
							if (separatorIndex === -1 || isoCode === null || isoCode === "") {
								isoCode = this.state.defaultCurrencyIsoCode;
								this.logmsg(
									"WARN",
									"Detected missing or invalid ISO code in the value " +
									"specified from the feed for CURRENCY_TYPE field '" +
									fieldDef.name +
									"'. Using the OpenPages default ISO code of '" +
									isoCode + "'.");
							}
							grcField.baseAmount = amount;
							grcField.localAmount = amount;
							// keep track of this field's ISO code for use when creating the
							// JSON for OP
							feedProps.currencyIsoCodes.putIfAbsent(fieldDef.id, isoCode);
							addedValue = true;
							break;
					}
				} catch (ex) {
					inError.push(this.message["Error creating GRC field"] + " - " + ex + " --> " + att.toString());
				}
			}
			if (inError.length > 0) {
				this.throwException(toJson(inError));
			}
			if (addedValue) {
				field[field.length] = grcField;
			}
			return grcField;
		},
		enumValue : function(attValue, fieldDef) {
			var enumValues = fieldDef.enumValues.enumValue;
			if (attValue === null) {
				return null;
			}
			attValue = attValue.trim();
			for (var i = enumValues.length - 1; i >= 0; i--) {
				var thisValue = enumValues[i];
				if (attValue.equalsIgnoreCase(thisValue.name) ||
					attValue.equalsIgnoreCase(thisValue.localizedLabel ||
						attValue.equalsIgnoreCase(thisValue.index))) {
					return {
						index : thisValue.index,
						hidden : thisValue.hidden,
						name : thisValue.name,
						id : thisValue.id,
						localizedLabel : thisValue.localizedLabel
					};
				}
			}
			return null;
		},
		parseDateValue : function(attValue) {
			if (typeof attValue === "undefined" || attValue === null) {
				return null;
			}
			var dt = system.parseDate(attValue, "EEE MMM dd HH:mm:ss z yyyy");
			if (dt === null) {
				dt = system.parseDate(attValue, ISOdateMask1);
			}
			if (dt === null) {
				dt = system.parseDate(attValue, ISOdateMask2);
			}
			if (dt === null) {
				try {
					var df = java.text.DateFormat.getDateInstance();
					dt = df.parse(attValue);
				} catch (ex) {
					dt = null;
				}
			}
			return dt;
		},
		// requests the client cert from the service and installs it into the SDI
		// keystore
		getCertificate : function() {
			return com.ibm.di.security.GetSSLCertificate.installCertificateFrom(
				this.state.connectionProperties.url, 443);
		},
		// examine the reply from OpenPages for any errors returned
		verifyResponse : function(replyEntry) {
			var respCode = replyEntry.getString("http.responseCode");
			if (!respCode.startsWith("2")) {
				this.throwException(this.message["Error from"] + " OpenPages server - code: " +
					respCode + "  message: " +
					replyEntry.getString("http.responseMsg") +
					"\nHTTP Body returned: " +
					replyEntry.getString("http.bodyAsString"));
			}
		},
		_getResourceCache : function() {
			if (! this.resourceCache) {
				var sysProps = java.lang.System.getProperties();
				this.resourceCache = sysProps.get("OPClientResourceCache");
				if (! this.resourceCache) {
					this.resourceCache = new java.util.concurrent.ConcurrentHashMap();
					sysProps.put("OPClientResourceCache", this.resourceCache);
				}
			}
			return this.resourceCache;
		},
		_getRequirementCache : function() {
			if (! this.requirementCache) {
				var sysProps = java.lang.System.getProperties();
				this.requirementCache = sysProps.get("OPClientRequirementCache");
				if (! this.requirementCache) {
					this.requirementCache = new java.util.concurrent.ConcurrentHashMap();
					sysProps.put("OPClientRequirementCache", this.requirementCache);
				}
			}
			return this.requirementCache;
		},
		cacheRequirement : function(name, requirement) {
			this._getRequirementCache().put(name, requirement);
		},
		getCachedRequirement : function(name) {
			return this._getRequirementCache().get(name);
		},
		getCachedResource : function(resourceKey) {
			return this._getResourceCache().get(resourceKey);
		},
		cacheResource : function(resourceKey, resourceObj) {
			this._getResourceCache().put(resourceKey, resourceObj);
		},
		clearResourceReferencesFromCache : function(containsKey) {
			var cache = this._getResourceCache();
			if (typeof cache.keys === "function") {
				var keysToRemove = [];
				cache.keys().forEach(function(key) {
					if (key.contains(containsKey)) {
						keysToRemove.push(key);
					}
				});
				keysToRemove.forEach(function(key) {
					cache.remove(key);
				});
			}
		},
		// workhorse function that handles all comms with OpenPages. It accepts a single
		// argument that is a Javascript object containing the properties set in the
		// first
		// lines of the function. Note that many of these properties are optional and
		// that
		// default values are set by the script is not specified.
		//
		makeRequest : function(args) {
			var requestInfo = this.formatRequestURL(args);
			if (requestInfo.resourceObj) {
				return requestInfo.resourceObj;
			}
			var retEntry = this.executeRequest(requestInfo.url);
			this.verifyResponse(retEntry);
			return this.parseReply(retEntry, requestInfo.resourceKey);
		},
		executeRequest : function(url) {
			var retry = 0;
			var maxRetry = 2;
			var retEntry = null;
			var error = null;
			// this loop makes the actual request. If an SSL handshake error occurs,
			// attempt to retrieve
			// and import the client certificate and inform the user that TDI must be
			// restarted.
			//
			do {
				try {
					retEntry = this.http.queryReply(this.requestEntry);
				} catch (ex) {
					if (ex instanceof javax.net.ssl.SSLHandshakeException) {
						if (retry === 0) {
							this.getCertificate();
						} else {
							this.throwException(this.message["You must restart the SDI server in order for the imported certificate to be trusted."]);
						}
					} else {
						error = ex.getMessage();
						break;
					}
				}
				retry++;
			} while (retEntry === null && retry < maxRetry);
			if (error || ! retEntry)  {
				var urlInfo = url;
				try {
					var parsedURL = new java.net.URL(url);
					urlInfo = parsedURL.getProtocol() + "://" + parsedURL.getAuthority();
				} catch (e) {}
				this.throwException("Cannot establish a connection to " + urlInfo + ".  Ensure that the target server is accessible and try again." +
					(error ?
						"  The connection error returned is " + error :
						""));
			}
			// if Detailed Log is enabled, write reply details to the log
			if (this.state.isDebug()) {
				this.logDetails({
					"msg" : this.message["Response from"] + " OpenPages",
					"entry" : retEntry
				});
			}
			return retEntry;
		},
		formatRequestURL : function(args) {
			var verb = args.verb || "GET"; 	// HTTP method, e.g. GET, POST, PUT, ...
			var url = args.url || ""; 		// url for the request. May be partial (only the path &
			var body = args.body; 			// HTTP body to be passed for the request
			var ctype = args.ctype || "application/json;charset=utf-8"; // Content-Type of the HTTP body
			var where = args.where || ""; 	// where this method is called from - for debugging
			url = this.state.fixPath(url);
			//
			// If getting a resource, check to see if it has been cached by it resource key (url) yet, and if so
			// return it now without rerequesting it from the server
			//
			var resourceKey = null;
			if (! args.ignoreCache && verb === "GET" && url) {
				resourceKey = url;
				var resourceObj = this.getCachedResource(resourceKey);
				if (resourceObj) {
					// this.logmsg("Found cached resource for url " + resourceKey);
					return {
						url : url,
						resourceKey : resourceKey,
						resourceObj : resourceObj
					};
				}
			}
			var cxn = this.state.connectionProperties;
			// prepend the base url if not found in the url passed to the function
			if (url.toLowerCase().indexOf(cxn.url.toLowerCase()) < 0) {
				url = cxn.url + url;
			}
			this.requestEntry.removeAllAttributes();
			if (typeof body !== "undefined" && body !== null && body.trim().length > 0) {
				this.requestEntry["http.body"] = body;
			}
			// set Connector parameters
			this.http.setParam("method", verb.toUpperCase());
			this.http.setParam("url", url);
			// prepare the request Entry (used for POST/PUT calls)
			this.requestEntry["http.Content-Type"] = ctype;
			this.requestEntry["http.Accept"] = "application/json;charset=utf-8";
			this.requestEntry["http.Connection"] = "keep-alive";
			this.requestEntry["http.remote_user"] = cxn.username;
			this.requestEntry["http.remote_pass"] = cxn.password;
			// the following are not used for now:
			//
			// requestEntry["http.Accept-Encoding"] = "gzip, deflate";
			// requestEntry["http.Accept-Language"] = "en-US,en;q=0.5";
			// requestEntry["http.User-Agent"] = "IBM Security Directory Integrator";
			// requestEntry["http.Authorization"] = "BASIC " +
			// system.base64Encode(String(user + ":" + password).getBytes());
			// add any cookies received on previous calls
			if (this.cookies && this.cookies.size() > 0) {
				// requestEntry["X-CouchDB-WWW-Authenticate"] = "Cookie";
				this.requestEntry.merge(this.cookies);
			}
			// if Detailed Log is enabled then write request details to the log
			if (this.state.isDebug()) {
				//noinspection JSPotentiallyInvalidUsageOfThis
				this.logDetails({
					msg : this.message["Request to"] + " OpenPages",
					obj : this.requestEntry,
					url : url,
					verb : verb,
					ctype : ctype,
					where : where
				});
			}
			return {
				url : url,
				resourceKey : resourceKey
			};
		},
		parseReply : function(replyEntry, resourceKey) {
			var body = replyEntry.getString("http.bodyAsString");
			if (body.trim().length === 0) {
				return;
			}
			// var decodedBody = null;
			// try { decodedBody = new java.lang.String(body.getBytes("UTF8"), "UTF8"); } catch (e) {}
			//
			// if (decodedBody) {
			// 	body = decodedBody;
			// }
			var jobj;
			try {
				if (this.state.isDebug()) this.logmsg("DEBUG", "body: " + body);
				//
				// TDIEvn.fromJson
				//
				jobj = fromJson(body);
				// save any cookies passed back
				var setCookie = replyEntry.getAttribute("http.Set-Cookie");
				if (setCookie !== null) {
					for (var i = 0; i < setCookie.size(); i++) {
						var thisCookie = setCookie.getValue(i);
						var p = thisCookie.indexOf("=");
						if (p > 0) {
							this.cookies["http." + thisCookie.substring(0, p)] = thisCookie.substring(p + 1);
						}
					}
				}
			} catch (ex) {
				this.throwException(this.message["Unable to parse JSON return from"] + " OpenPages - " + ex);
			}
			//
			// If a resourceKey is set, then this is a get request for a resource that has been retrieved for the first
			// time in the execution of this assembly line instance.  Cache the resource away for later recall in case
			// it is re-requested on this or subsequent iterations.
			//
			if (resourceKey && jobj) {
				// this.logmsg("INFO", "Caching resource data for url " + resourceKey);
				// this.logmsg("INFO", "Resource object: " + this.toJsonString(jobj));
				this.cacheResource(resourceKey, jobj);
			}
			return jobj;
		},
		logmsg : function (lvl, msg) {
			lvl = lvl || "";
			if (! msg) {
				msg = lvl;
				lvl = "INFO";
			}
			// if Detailed Log is enabled then log output is also sent to the stdout
			if (this.state.isDebug()) {
				java.lang.System.out.println(msg);
			}
			try {
				task.logmsg(lvl, msg);
			} catch (ex) {
				main.logmsg(lvl, msg);
			}
			// send an email notification
			if (lvl === "ERROR") {
				this.mailer.sendEmailNotification(msg);
			}
		},
		// write request or reply details to the log
		logDetails : function(params) {
			var msg = params.msg;
			var obj = params.obj;
			var url = params.url;
			var verb = params.verb;
			var ctype = params.ctype;
			var where = params.where;
			if (msg === null) {
				msg = message["Unnamed entry"];
			}
			var s = new java.lang.StringBuffer();
			if (where !== null) {
				s.append("\n@@@------> (" + where + ") " + msg);
			} else {
				s.append("\n---------> " + msg);
			}
			if (verb !== null) {
				s.append("   " + verb.toUpperCase());
			}
			if (ctype !== null) {
				s.append("   " + ctype);
			}
			if (url !== null) {
				s.append("   " + url);
			}
			s.append("\n");
			if (obj !== null) {
				if (obj instanceof com.ibm.di.entry.Entry) {
					var attNames = obj.getAttributeNames();
					for ( var a in attNames) {
						// include all "http.*" attributes, except bodyAsBytes
						if (a.indexOf("http.") >= 0 && !"http.bodyAsBytes".equalsIgnoreCase(a) && !"http.remote_pass".equalsIgnoreCase(a)) {
							s += " " + a + ": " + obj[a] + "\n";
						}
					}
				} else {
					s.append(obj.toString());
				}
			}
			this.logmsg(s.toString());
		},
		// wrapper function for throwing exceptions. Otherwise exceptions thrown will be
		// 'script' exceptions
		throwException : function (msg) {
			this.logmsg("ERROR", msg); // will also send an email notification
			throw new java.lang.IllegalArgumentException(msg);
		},
		throwNotInitializedError : function() {
			this.throwException("The OpenPages Connector must be initialized before use.");
		},
		getResultObjectFields : function(jobj) {
			if (jobj.fields && jobj.fields.field) {
				return jobj.fields.field;
			}
			if (jobj.rows && jobj.rows.length && jobj.rows[0].fields && jobj.rows[0].fields.field) {
				return jobj.rows[0].fields.field;
			}
		},
		grcObjectToEntry : function(jobj) {
			var entry = system.newEntry();
			var inError = [];
			var i;
			try {
				var type = null;
				var links = jobj.links;
				if (typeof links !== "undefined") {
					for (i = 0; i < links.length; i++) {
						if ("describedby".equals(links[i].rel.toLowerCase().trim())) {
							type = links[i].href.substring(9);
							var p = type.indexOf("?");
							type = type.substring(0, p);
						}
					}
					if (type !== null) {
						entry.$grcObjectType = type;
					}
				}
				var fields = this.getResultObjectFields(jobj);
				if (typeof fields !== "undefined") {
					for (i = 0; i < fields.length; i++) {
						this.addGrcAttribute(entry, fields[i]);
					}
				}
				if (entry.size() > 0) {
					entry.$grcObject = jobj;
					entry.$grcObjectJSON = this.makeJson(jobj);
				}
			} catch (ex) {
				inError.push(this.message["Error parsing json from OpenPages"] + " - " + ex + "  -> " + this.makeJson(jobj));
			}
			if (inError.length > 0) {
				this.throwException(toJson(inError));
			}
			return entry;
		},
		objectToEntry : function(jobj) {
			var entry = system.newEntry();
			for (var prop in jobj) {
				var propValue = jobj[prop];
				if (typeof propValue !== "object") {
					entry[prop] = propValue;
				} else if (prop === "fieldDefinitions" && propValue.fieldDefinition) {
					var defs = [];
					for (var i=0; i < propValue.fieldDefinition.length; i++) {
						var fieldDef = propValue.fieldDefinition[i];
						defs.push({
							id : fieldDef.id,
							name : fieldDef.name,
							dataType : fieldDef.dataType,
							required : fieldDef.required,
							readOnly : fieldDef.readOnly
						})
					}
					entry["fieldDefinitions"] = toJson(defs);
				}
			}
			return entry;
		},
		addGrcAttribute : function(entry, field) {
			if (typeof field === "undefined" || field === null) {
				return;
			}
			var fieldName = field.name;
			var fieldValue = field.value;
			if (typeof fieldName !== "undefined" && fieldName !== null && fieldName.trim().length > 0) {
				fieldName = fieldName.trim();
				try {
					switch (field.dataType) {
						case "STRING_TYPE":
						case "MEDIUM_STRING_TYPE":
						case "LARGE_STRING_TYPE":
						case "ID_TYPE":
						case "BOOLEAN_TYPE":
							if (fieldValue) {
								this.addAttributeValue(entry, fieldName, fieldValue);
							}
							break;
						case "FLOAT_TYPE": // Handles any floating point decimal value as a
							// double value
							if (fieldValue) {
								var doubleVal = 0.0;
								try {
									doubleVal = java.lang.Double.parseDouble(fieldValue);
								} catch (ex) {
									doubleVal = "Error parsing floating point value: " + fieldValue;
								}
								this.addAttributeValue(entry, fieldName, doubleVal);
							}
							break;
						case "INTEGER_TYPE":
							if (fieldValue) {
								var intValue = 0;
								try {
									intValue = system.toInt(fieldValue);
								} catch (ex) {
									intValue = "Error parsing integer value: " + fieldValue;
								}
								this.addAttributeValue(entry, fieldName, intValue);
							} else {
								entry[fieldName] = null;
							}
							break;
						case "ENUM_TYPE":
							if (field.enumValue) {
								if (typeof field.enumValue.name !== "undefined") {
									this.addAttributeValue(entry, fieldName,
										field.enumValue.name);
								}
								if (field.enumValue.index) {
									this.addAttributeValue(entry, fieldName + "_index",
										field.enumValue.index);
								}
							}
							break;
						case "MULTI_VALUE_ENUM":
							if (typeof field.multiEnumValue !== "undefined") {
								var enums = field.multiEnumValue.enumValue;
								if (typeof enums !== "undefined" && enums.length > 0) {
									for (var i = 0; i < enums.length; i++) {
										this.addAttributeValue(entry, fieldName, enums[i].name,
											false);
									}
								}
							}
							break;
						case "DATE_TYPE":
							if (fieldValue) {
								if (fieldValue && fieldValue.endsWith("Z")) {
									fieldValue = fieldValue.substr(0, fieldValue.length-1);
								}
								var dateValue = system.parseDate(fieldValue,
									"yyyy-MM-dd'T'HH:mm:ss.SSS");
								if (dateValue === null) {
									this.logmsg("WARN",
										this.message["Unable to parse DATE_TYPE value for"] + " " + fieldName + ": " + fieldValue);
								}
								this.addAttributeValue(entry, fieldName, dateValue);
							}
							break;
						case "CURRENCY_TYPE":
							this.addAmount(entry, fieldName, "", field.baseAmount,
								field.baseCurrency);
							this.addAmount(entry, fieldName, "_localAmount", field.localAmount,
								field.localCurrency);
							break;
					}
				} catch (ex) {
					if (this.state.isDebug())
						this.logmsg("DEBUG", "--!!--> Error parsing GRC field: " + toJson(field) + " - " + ex);
				}
			}
		},
		addAttributeValue : function(entry, attName, attValue, replace) {
			if (typeof attName === "undefined" || attName === null) {
				return;
			}
			if (typeof replace === "undefined" || !"false".equalsIgnoreCase(replace)) {
				replace = true;
			}
			if (typeof attValue === "undefined" || attValue === null) {
				entry[attName] = entry.returnJavaNull;
			} else if (replace) {
				entry.setAttribute(attName, attValue);
			} else {
				entry.addAttributeValue(attName, attValue);
			}
		},
		addAmount : function(entry, attName, attSuffix, attValue, currency) {
			if (typeof attName === "undefined" || attName === null) {
				return;
			}
			var doubleVal;
			try {
				doubleVal = java.lang.Double.parseDouble(attValue);
			} catch (ex) {
				doubleVal = "Error parsing amount: " + attValue + " - " + ex;
			}
			this.addAttributeValue(entry, attName + attSuffix, doubleVal);
			if (typeof currency !== "undefined" && typeof currency.isoCode !== "undefined") {
				this.addAttributeValue(entry, attName + attSuffix + "_currency",
					currency.isoCode);
			}
		},
		nl : function(pad) {
			if (this.state.isDebug()) {
				return "\n                                            ".substring(0,
					(pad * 4) + 1);
			} else {
				return "";
			}
		},
		toJsonString : function(obj) {
			return this.json.toJsonString(obj);
		},
		makeEnumJson : function(enumVal) {
			var json = new java.lang.StringBuffer();
			json.append(this.nl(6) + '{"index" : ' + enumVal.index + ',' + this.nl(6) +
				'"hidden" : ' + enumVal.hidden + ',' + this.nl(6) + '"id" : "' +
				enumVal.id + '",' + this.nl(6) + '"name" : "' + enumVal.name + '",' +
				this.nl(6) + '"localizedLabel" : "' + enumVal.localizedLabel + '"}');
			return json.toString();
		},
		makeCurrencyJson : function(field, prop) {
			var json = new java.lang.StringBuffer();
			// The baseCurrency and localCurrency properties contain properties of
			// their own; special handling is performed here
			if (prop == "baseCurrency" || prop == "localCurrency") {
				var thisField = field[prop];
				json.append('"' + prop + '" :' + this.nl(6) + '{"isoCode" : "' +
					thisField.isoCode + '",' + this.nl(6) + '"name" : "' +
					thisField.name + '",' + this.nl(6) + '"symbol" : "' +
					thisField.symbol + '",' + this.nl(6) + '"precision" : ' +
					thisField.precision + ',' + this.nl(6) + '"isBaseCurrency" : ' +
					thisField.isBaseCurrency + ',' + this.nl(6) + '"isEnabled" : ' +
					thisField.isEnabled + ',' + this.nl(6) + '"id" : "' + thisField.id +
					'"}');
				return json.toString();
			} else {
				// Ensure that the localAmount has a localCurrency, which is
				// required for setting or updating a currency amount in OP. It
				// gets added here automatically since the currency field definition
				// does not specify any metadata for the ISO code.
				var isoCode = this.feedProps.currencyIsoCodes.get(field.id);
				if (prop == "localAmount" && isoCode !== null) {
					json.append('"' + prop + '" : ' + field[prop] + ',' + this.nl(4) +
						'"localCurrency" : ' + this.nl(6) + '{"isoCode" : "' + isoCode +
						'"},');
					return json.toString();
				} else {
					// all other currency properties are 'simple'
					return '"' + prop + '" : ' + field[prop];
				}
			}
		},
		makeValueJson : function(field, prop) {
			var json = new java.lang.StringBuffer();
			var thisField = field[prop];
			if ("MULTI_VALUE_ENUM".equals(field.dataType)) {
				json.append(this.nl(4) + '"multiEnumValue" : {' + this.nl(5) + '"enumValue" : [');
				for (var i = 0; i < thisField.length; i++) {
					if (i > 0) {
						json.append(",");
					}
					json.append(this.makeEnumJson(thisField[i]));
				}
				json.append(this.nl(5) + "]" + this.nl(4) + "}");
			} else if ("ENUM_TYPE".equals(field.dataType)) {
				json.append(this.nl(4) + '"enumValue" : ' + this.makeEnumJson(thisField));
			} else if ("CURRENCY_TYPE".equals(field.dataType)) {
				json.append(this.nl(4) + this.makeCurrencyJson(field, prop));
			} else {
				json.append(this.nl(4) + '"value" : ' + toJson(thisField));
			}
			return json.toString();
		},
		isJsonFieldPropIncluded : function(prop) {
			return ! "dataType".equals(prop) &&
				!"hasChanged".equals(prop) &&
				!"id".equals(prop) &&
				!"name".equals(prop);
		},
		formatJsonFieldStart : function(field) {
			return this.nl(3) +
				"{" +
				this.nl(4) +
				'"dataType" : "' +
				field.dataType +
				'",' +
				this.nl(4) +
				'"id" : "' +
				field.id +
				'",' +
				this.nl(4) +
				'"name" : "' +
				field.name +
				'",';
		},
		makeFieldJson : function(field) {
			var json = new java.lang.StringBuffer();
			json.append(this.formatJsonFieldStart(field));
			var started = false;
			for (var prop in field) {
				if (this.isJsonFieldPropIncluded(prop)) {
					if (! started) {started = true;} else {json.append(",");}
					json.append(this.makeValueJson(field, prop));
				}
			}
			json.append(this.nl(3) + "}");
			return json.toString();
		},
		makeFieldsJson : function(fields) {
			var json = new java.lang.StringBuffer();
			var started = false;
			for (var i = 0; i < fields.length; i++) {
				if (! started) {started = true;} else {json.append(",");}
				json.append(this.makeFieldJson(fields[i]));
			}
			return json.toString();
		},
		makeJson : function(jobj) {
			var json = new java.lang.StringBuffer("{");
			for (var prop in jobj) {
				if (typeof jobj[prop] !== "object") {
					json.append(this.nl(1) + '"' + prop + '" : ' + toJson(jobj[prop]) + ',');
				}
			}
			json.append(this.nl(1) + '"fields" : { ' + this.nl(2) + '"field" : [');
			json.append(this.makeFieldsJson(this.getResultObjectFields(jobj)));
			json.append(this.nl(2) + "]" + this.nl(1) + "}" + this.nl(0) + "}");
			return json.toString();
		}
	};
};
//noinspection JSAnnotator
return OpenPagesApiClient;]]></parameter>
    </Script>
</MetamergeConfig>