<?xml version="1.0" encoding="UTF-8"?><MetamergeConfig Cycle="393" UUID="cc2c1334-a20f-4535-ba0b-de021014c4e4" created="Mon Oct 12 16:40:29 CEST 2020" createdBy="eddie" main="ePolicy2OP_define service functions" modified="Wed Dec 23 14:01:53 CET 2020" modifiedBy="eddie" project="POC_MVP" version="7.1.1">
    <Script name="ePolicy2OP_define service functions">
        <ModTime>1608728512858</ModTime>
        <parameter name="includeFiles"/>
        <parameter name="script"><![CDATA[// Functions used by this AL
// Gather metrics from the passed AL, returning an object with the following properties:
//	errors		- object, account-property based array of errors
//	warnings	- object, account-property based array of warnings
//  counters		- object, account-property based array of creation counters
//  timers		- object, account-property based array of timers
function gatherMetrics(al, errors, warnings, counters, alTimers) {
	var ignoreMissingWork = (typeof errors == "undefined") ? true : false;
		
	errors = errors || {};
	warnings = warnings || {};
	counters = counters || {};
	alTimers = alTimers || {};
	
	var state = al.getCurrentStep();
	// Only check the work entry if the AL is actually cycling
	if (state >= 8) {
		try {
			// Get the current Work Entry
			var entry = al.getResult();
			
			if (entry != null) {
				// Get the metrics object
				alMetrics = entry.getObject("_metrics");
				
				if (alMetrics == null) {
					log("WARN", "No metrics returned for " + al.getShortName());
					continue;
				}
				
				var accountName = alMetrics.accountName;
				//var CSD_Name = al.getParam("CSD_Name") + " " || "";
				
				errors[accountName] = errors[accountName] || [];
				if (alMetrics.errors.length > 0) {
					errors[accountName].push(alMetrics.errors[0]);
				}
/*				
				for (i in alMetrics.errors) {
					errors[accountName].push(alMetrics.errors[i]);
				}
*/		
				warnings[accountName] = warnings[accountName] || [];
				for (i in alMetrics.warnings) {
					warnings[accountName].push(alMetrics.warnings[i]);
				}
		
				var alCounters = alMetrics.counters;
				
				alCounters.Status = alCounters.Status || {};
				alCounters.Status[accountName] = (step == 16) ? (alCounters.Status[accountName] != "In Progress" ? "Completed" : "In Progress") : "In Progress";
		
				for (var item in alCounters) {
					counters.Service = counters.Service || {};
					if (item == "Policy_Names") {
						counters.Service.Policy_Names = counters.Service.Policy_Names || [];
						if (alCounters.Policy_Names && alCounters.Policy_Names.length > 0) {
							counters.Service.Policy_Names = counters.Service.Policy_Names.concat(alCounters.Policy_Names);
						}
					} else
					if (item == "Status") {
						counters.Status = counters.Status || {};
						counters.Status[accountName] = alCounters.Status[accountName];	
					} else {
						counters[accountName] = counters[accountName] || {};
					 	counters.Service[item] = (counters.Service[item] || 0) + alCounters[item];
					 	counters[accountName][item] = (counters[accountName][item] || 0) + alCounters[item];
					}
				}
		
				var alTimers = alMetrics.timer.timers();
				
				for (var item in alTimers) {
					timers.Service = timers.Service || {};
					timers[accountName] = timers[accountName] || {};
					timers.Service[item] = (timers.Service[item] || 0) + alTimers[item];
					timers[accountName][item] = (timers[accountName][item] || 0) + alTimers[item];
				}
			}
		} catch (excptn) {
			log("ERROR", "Error gathering metrics from " + al.getParam("alName") + " - " + excptn);
		}
	}	
		
	return {
		errors: errors,
		warnings: warnings,
		counters: counters,
		timers: timers
	}
}	

// Return the capitalized name of the operation
function operationName(op) {
	switch (op) {
		case "validate": return "Validation";
		case "migrate": return "Migration";
		default: return "Processing"
	}
}

// Change the responseObj with error settings
function responseError(code, msg, errorMsg, message, entry) {
	entry = entry || work;
//	if (!responseObj.code.startsWith("2")) {
//		return;
//	}

	if (typeof responseObj == "undefined") {
		responseObj = {};
	}

	log("ERROR", errorMsg);
	if (!code.startsWith("2")) { 
		responseObj.code = code;
		responseObj.msg = msg;
		responseObj.message = message || msg;
		responseObj.errorMsg = errorMsg || message || msg;
		responseObj.errors.push(errorMsg);
	}
	
	entry["http.responseCode"] = responseObj.code;
	entry["http.responseMsg"] = responseObj.msg;
	entry["http.message"] = entry["http.message"] || responseObj.message;
	entry["http.errorMsg"] = responseObj.errorMsg;
	log("DEBUG", "Setting response to: " + errorMsg);
    entry["http.Content-Type"] = "application/json";
}

// Setting up response for client
function response(code, msg, message, body, entry) {
	entry = entry || work;
	entry["http.body"] = body;

	// If already set (like for an error) do not change code and message
	
	if (entry["http.responseCode"] != null) {
		return;
	}
	
	entry["http.responseCode"] = code;
	entry["http.responseMsg"] = msg;
	entry["http.message"] = entry["http.message"] || message;
    entry["http.Content-Type"] = "application/json";

//	log("ERROR", "Response is now: " +  entry);
	responseMade = true;
	return entry;
}

var responseAlreadyMade = false;
// Create the return response to the client
function makeResponse(useEntry, requestID, operation, accounts, counters, errors, warnings, timers) {
	accounts = accounts || [];
	counters = counters || {};
	errors = errors || {};
	warnings = warnings || {};
	timers = timers || {};
	//log("=====\n=====\n===== Making Response In Entry: " + useEntry);
	var responseObj = responseObj || {};
	
	if (responseAlreadyMade) {
		return;
	}
	responseAlreadyMade = true;
	// If GET request, return reply
	if (typeof getRequest != "undefined") {
		response("200", "Service is alive", "Service is alive", toJson({message: "Service is alive"}), null);
		return;
	}
	
	// Make the response, based on the operation
	
	// Go through each account passed in the request. The various
	// metrics objects, like errors and counters, have a property for each
	// accountName that holds the data related to that account.
	var accountsInError = [];
	for (var i in accounts) {
		accountName = accounts[i];
		
		var useErrors = errors[accountName] || [];
		if (!(useErrors instanceof Array)) {
			useErrors = [useErrors];
		}
		// If errors were found, attach them
		if (useErrors.length > 0) {
			accountsInError.push(accountName);
		}

		// Set up an object for each account with name, status, error (if any) and created properties	
		accountObj = {
			name: accountName,
			status: (useErrors.length > 0) ? "Failed" : "Success",
			error: (useErrors.length > 0) ? useErrors[0] : ""
		};
		
		if (counters[accountName]) {
			//accountObj.created = counters[accountName];
			var createdArray = [];
			for (var objType in counters[accountName]) {
				createdArray.push(objType + ": " + counters[accountName][objType]);
			}
			accountObj.created = createStr + createdArray.join(", ");
		}
		
		accountObj.message = accountObj.error || accountObj.created || "";
		
		responseObj.accounts = responseObj.accounts || [];
		responseObj.accounts.push(accountObj);
	}
	
	// Now change the response status property if some or all accounts show failure
	if (accountsInError.length == accounts.length) {
		responseError("400", 
						"Bad Request",
						operationName(operation) + " of all accounts failed",
						"See Account details for more information");
		responseObj.status = "Failed";
	} else 
	if (accountsInError.length > 0) {
		responseError("400", 
//						"Partial Failure",
						"Failed",
						operationName(operation) + " of the following accounts failed: " 
							+ accountsInError.join(", "),
						"See Account details for more information");
//		responseObj.status = "Partial Failure";
		responseObj.status = "Failed";
		responseObj.errors = [];
	}	
		
	if (accountsInError.length > 0) {
		log("ERROR", "One or more Accounts in error: " + accountsInError.join(", "));
	}

	// Set the create string based on doMigration or not
	var createStr = doMigration ? "Created " : "Will create ";
	
	// Look at errors collected during log("ERROR", ...) done by this main listener thread.
	// If errors found, report these first as they are problems for the Service itself
	if (typeof useEntry == "undefined" || useEntry == null || accounts == null) {
		log("ERROR", "Unable to process request");
	}
	if (inError()) {
		var code = useEntry.getString("http.responseCode");
		if (code && code.startsWith("2")) {
			code = 400;
		}
		response(code, 
				useEntry.getString("responseMsg") || "Bad Request",
				"Could not process " 
					+ operationName(operation) 
					+ " request " + requestID 
					+  " due to error: " + rootCause());
		responseObj.status = "Failed";
	} else {
		// Prepare for adding AL metrics to the overall results
		operation = operation || "validate"
		responseObj.message = "The " 
								+ operationName(operation) 
								+ " request completed successfully";
		
		if (typeof counters != "undefined" && counters.Service) {
			var createdArray = [];
			for (var objType in counters.Service) {
				createdArray.push(objType + ": " + counters.Service[objType]);
			}
			responseObj.created = createStr + createdArray.join(", ");
		}
	} // for each accountName passed
	
	//resetErrors();
	
	if (debug) {
		responseObj.debug = "DEBUG MODE";
	}
	
	response(responseObj.code, responseObj.msg, responseObj.message || "", toJson(responseObj), useEntry);
	
	// Log response to Client
	log("Returning resultCode: " + useEntry);
	
	// Print counters to the log 
	logCounters();

	if (opUserEmail == null) {
		log("ERROR", "No OpenPages User email address passed in request");
	} else {
		sendEmail(opUserEmail, requestID, useEntry, operation, accounts, counters, errors, warnings, timers, "Completed");
	}
}

// Simple function to stringify a JS object, used by logMetrics()
function showJson(obj, lvl) {
	lvl = lvl || 0;
	var sb = java.lang.StringBuilder();
	var pad = "                                  ".substring(0, lvl*4);
	if (typeof obj != "object" || obj == null) {
		sb.append(pad + obj + "\n");
	} else {
		for (var propName in obj) {
			var subobj = obj[propName];
			if (subobj instanceof Array) {
				if (subobj.length > 0) {
					sb.append(pad + "  " + propName + ": [\n");
					for (var i = 0; i < subobj.length; i++) {
						sb.append(showJson(subobj[i], lvl+1) + "\n");
					}
					sb.append(pad + "]\n");
				}
			} else
			if (typeof subobj == "object") {
				sb.append(pad + "  " + propName + ": {\n");
				sb.append(showJson(subobj, lvl+1) + "\n");
				sb.append(pad + "  }\n");
			} else {
				sb.append(pad + "  " + propName + ": " + subobj + "\n");
			}
		}
	}
	return sb.toString();
}

// Log out request operation metrics
function logCounters(){
	
	if (!timer || !timer.timers() || !timer.timers().Service) {
		return;
	}
	
	// Log all creations
	log("--------- Objects created:\n" + showJson(counters));
	log("");
	log("--------- Errors:\n" + showJson(errors));
	log("");
	//log("--------- Warnings:\n" + showJson(warnings));
	
	// Show timing metrics - those for Service are the accumulation
	var serviceTimers = timer.timers().Service;
	var timingMap = new java.util.HashMap();
	for (var itemName in serviceTimers) {
		timingMap.put(itemName, serviceTimers[itemName]);
	}
	var timingArray = timingMap.keySet().toArray();
	java.util.Arrays.sort(timingArray);
	
	var i = 0;
	for (var itemName in timingArray) {
		var timing = timingMap[itemName];
		var seconds = Math.round(timing/1000);
		var minutes = Math.floor(seconds / 60);
		var secondsAfter = seconds % 60;
		log("    " + LJ(itemName, 65, i) 
					+ RJ(minutes, 11, i) + " min"
					+ RJ(secondsAfter, 3) + " sec");
		i++;
	}
}

// Build email message based on service results
function buildMailMessage(requestID, workEntry, operation, accounts, counters, errors, warnings, timers, progressText) {
	counters = counters || {};
	errors = errors || {};
	warnings = warnings || {};
	timers = timers || {};
	workEntry = workEntry || system.newEntry();
	
	requestID = requestID || null;
	progressText = progressText || "Completed";
	
	if(typeof accounts == "undefined" || accounts == null || !accounts.length || workEntry == null){
		return "";	
	}	

	var firstColWidth = 20;
	var nameColWidth = 20;
	var opNoun = (operation == "migrate") ? "Migration" : "Validation";
	var opNouned = (operation == "migrate") ? "Migrated" : "Validated";
	var policyCnt = {};
	var accountError = {};
	var accountsInError = [];
	
	var responseCode = workEntry.getString("http.responseCode") || "200";
	
	// Start off with the header
	var lines = ["<!DOCTYPE html><html><head><style>table, th, td {border: 1px solid black;border-collapse: collapse;}</style></head><body>",
				 "<h1>IBM Global GTS SR&RM - OpenPages - " + progressText + "</h1>"
				 "<hr width:100% size:20px/>"];

	// Add the requestID
	if (requestID) {
		lines.push("<br/><h2>Request " + requestID + " - " + progressText + "</h2><br/>");
	}

	// Now a little title information
	lines.push("<div>Below are details of the requested ePolicy " + opNoun 
				+ " " + progressText + " on "
				+ system.formatDate(new Date(), "d-MMM-yyyy HH:mm:ss") + "</div>");
	lines.push("<div><h2>" + opNoun + " Status:</h2></div>");

    // First go through each Account passed in the request to see if
    // there are errors for that Account
    for (var i in accounts) {
	    var accountName = accounts[i];
	    if ((accountName.length+1) > nameColWidth) {
	    	nameColWidth = accountName.length+1;
	    }
    
	    var useErrors = errors[accountName] || [];
	    if (!(useErrors instanceof Array)) {
		    useErrors = [useErrors];
		}
	    // If errors were found, attach them
	    if (useErrors.length > 0) {
		    accountError[accountName] = useErrors.join("ยง");
		    accountsInError.push(accountName);
		    responseCode = (responseCode == "200") ? "400" : responseCode;
	    }
	}
	
	// Now start creating mail body lines

	lines.push("<table>")
	var lineCnt = 0;
	lines.push('<tr><td style="color:white;background-color:gray">ePolicy Instance</td><td>' + ePolicy.hostname + "</td></tr>");
	
	// Get the status from the response attribute already set up in the passed Entry (workEntry)
	var responseMsg = workEntry.getString("http.responseMsg") || "OK";
	if (responseCode == "400") {
		responseMsg = (responseMsg == "OK" || !responseMsg) ? "Bad Request" : responseMsg;
	}
/*	
	if (inError() != (!responseCode.startsWith("2"))) {
		log("DEBUG", "Error - inconsistent error signalling:\n"
						+ "   Response code: " + responseCode + "\n"
						+ "    Response msg: " + responseMsg + "\n"
						+ "Errors are:\n     " 
						+ _errors.join("\n     "))
	}
*/
	var opStatement = "Completed".equalsIgnoreCase(progressText) ? " Accounts " + opNouned : " Accounts being " + opNouned;
	var failureText = "Completed".equalsIgnoreCase(progressText) ? "failed" : "failing";
	
	if (inError()) {
		lines.push('<tr><td style="color:white;background-color:gray">Status</td><td>' + opNoun 
						+ " " + failureText + "</td></tr>");
		lines.push('<tr><td style="color:white;background-color:gray">Detailed Status</td><td>' + rootCause() + "</td></tr>");
	} else {
		if (accountsInError.length == 0) {
			lines.push('<tr><td style="color:white;background-color:gray">Status</td><td>' 
						+ opNoun + " " + progressText + "</td></tr>");
			lines.push('<tr><td style="color:white;background-color:gray">Detailed Status</td><td>' 
						+ accounts.length 
						+ opStatement + "</td></tr>");
			
		} else {
			lines.push('<tr><td style="color:white;background-color:gray">Status</td><td>' + opNoun + " " +
							failureText + " for " + accountsInError + " Accounts</td></tr>");
			lines.push('<tr><td style="color:white;background-color:gray">Detailed Status</td><td>'
						+ "The following accounts fail to " + operation + ": "
						+ accountInError.join(", ") + "</td></tr>");
		}	
	}	
	
	if (counters.Service) {
		policiesMigrated = counters.Service.Policy_Names;
	} else {
		policiesMigrated = [];
	}
	
	if (!"Initiated".equalsIgnoreCase(progressText)) {
		if (operation == "migrate") {
			//lines.push('<tr><td style="color:white;background-color:gray">' + opNouned + '</td><td>' + accountsMigrated + "</td></tr>");		
			lines.push('<tr><td style="color:white;background-color:gray">Policies ' + opNouned + '</td><td>' + policiesMigrated.join("<br/>") + "</td></tr>");		
//		} else {
//			lines.push('<tr><td style="color:white;background-color:gray">Accounts ' + opNouned + '</td><td>' + accountsMigrated + "</td></tr>");		
		}
	}

	lines.push('<tr><td style="color:white;background-color:gray">Migration Start</td><td>' + system.formatDate(migrationStart, "dd-MMM-yyyy HH:mm:ss") + "</td></tr>");
	if (typeof migrationEnd != "undefined" && migrationEnd != null) {
		lines.push('<tr><td style="color:white;background-color:gray">Migration End</td><td>' + system.formatDate(migrationEnd, "dd-MMM-yyyy HH:mm:ss") + "</td></tr>");
	}
	lines.push("</table>");

	lines.push("<div><h2>Account Details:</h2></div>");

	lines.push("<table>");	
	lines.push('<tr><td><b>Account Name</b></td><td><b>Details</b></td></tr>');
	for (var i in accounts) {
		var accountName = accounts[i];
		counters.Status = counters.Status || {};
		
		var accErrors = errors[accountName] || [];
		if (accErrors.length > 0) {
			var details = accErrors;
			if (accErrors instanceof Array) {
				details = accErrors.join("|");
			}
		} else {
			var details = accountError[accountName] || opNoun 
				+ " " + (counters.Status[accountName] || progressText);
		}
		
		var style = "";
		if (inError() || (accountError[accountName] && accountError[accountName].length > 0)) {
			style = ' style="color:red"';
		}	
		lines.push('<tr><td' + style + '>' + accountName + "</td><td>" 
				+ details
					.replace("|", "<br/>.<br/>")
					.replace("ยง", "<hr width:100% size:20px/>")
				+ "</td></tr>");
	}
	lines.push("</table>");
	
	lines.push("<br/>");
	
	// If no errors and at least one Account is successfully validated, then include the link to the Migrate UI page
	if ("Completed".equalsIgnoreCase(progressText)
		&& !inError() 
		&& responseCode == "200" 
		&& operation == "validate") {
		lines.push("<b>Ensure you are logged into OpenPages and then click on "
					+ '<a href="' + migrateURL + "?param=" + requestID + '">this link</a>'
					+ " to perform Migration.</b>")
	} 
	
	lines.push("<br/><br/>");
	lines.push('<div>For more information on GTS Global ITRM Process and OpenPages implementation refer to <a href="https://w3-connections.ibm.com/wikis/home?lang=en#!/wiki/Wf49a2ed8f3ed_49c2_bc11_b9e51af1f556/page/Welcome%20to%20OpenPages">ITRM OpenPages wiki</a></div>');
	lines.push("<hr width:100% size:10/>");
	lines.push('<div style="color:white;background-color:black">This email is auto generated by IBM OpenPages GRC Platform. Have a question? Click <a href="mailto://itrmop@us.ibm.com">here</a> to write to us.</div>')

	lines.push("</body></html>")

	//log("DEBUG", "\nNotification mail body:\n\n" + lines.join("\n") + "\n");
	workEntry["http.responseCode"] = responseCode;
	workEntry["http.responseMsg"] = responseMsg;

	return lines.join("");
}

// Returns vital SMTP properties
function getSMTPProperty(propName) {
	var val = system.getTDIProperty(propName);
	if (val == null) {
		log("ERROR", "Missing SMTP property: " + propName);
	}
	return val;
}

// Send out the notification email
function sendEmail(toUser, requestID, workEntry, operation, accounts, counters, errors, warnings, timers, progressText) {
	progressText = progressText || "Completed";
	
	var hostname = getSMTPProperty("smtp.hostname");
	var port = getSMTPProperty("smtp.port");
	var username = getSMTPProperty("smtp.username");
	var password = getSMTPProperty("smtp.password");
	
	if (!hostname || !port || !username || !password) {
		log("WARN", "Cannot send notification email because settings are incorrect");
		return;
	}

	if (!(toUser instanceof Array)) {
		toUser = [toUser];
	}
	var extraTarget = system.getTDIProperty("mail.extra.target");
	if (extraTarget != null && typeof extraTarget == "string" && extraTarget.contains("@")) {
		toUser.push(extraTarget);
	}

	try {
		var mail = new MailObj({
			hostname: hostname,
			port: port,
			username: username,
			password: password,
			ssl: true
		});
		var opNoun = (operation == "migrate") ? "Migration" : "Validation";
		var body = buildMailMessage(requestID, workEntry, operation, accounts, counters, errors, warnings, timers, progressText);
		if (body == "") {
			log("WARN", "Not sending email with empty body");
		} else {
			mail.send({
				to: toUser,
				from: "SDI@IBM.COM",
				subject: "ePolicy " + opNoun + " result notification - " 
							+ requestID + " " + progressText,
				body: body,
				contentType: "text/html"
			});
		}
	} catch (ex) {
		log("WARN", "Error sending notification email - " + ex);
	}
}

// Return a new Request ID
function newRequestID() {
	var id = system.formatDate(new Date, "yyMMdd") + randomPart(10);
	return id;
}

// Generate the random part of a Request ID
function randomPart(len) {
	len = len || 5;
	var charStr = "ABCDEFGHIJKLMNOP0123456789";
	var chars = charStr.split();
	var buf = new java.lang.StringBuilder();
	
	while (buf.length() < len) {
		var ndx = Math.floor(Math.random() * chars.length);
		buf.append(chars[ndx]);
	}
	
	return buf.toString();
}

// Count running ALs
function runningALs(als) {
	var runningCnt = 0;
	for (var alObj in als) {
		var al = alObj.al;
		if (!al || al.getCurrentStep() >= 16) {
			// not running
		} else {
			runningCnt++;
		}
	}
	return runningCnt;
}

// Send notification email
function sendNotificationEmail(args) {
	var nextStatus = args.nextStatus;
	var opUserEmail = args.opUserEmail;
	var requestID = args.requestID;
	var workEntry = args.workEntry;
	var operation = args.operation;
	var accounts = args.accounts;
	
	var now = java.lang.System.currentTimeMillis();
	if (now > nextStatus) {
		var alErrors = {};
		var alWarnings = {};
		var alCounters = {};
		var alTimers = {};
		for (var thisAL in als) {
			alMetrics = gatherMetrics(thisAL.al, alErrors, alWarnings, alCounters, alTimers) || {};
			alErrors = alMetrics.errors;
			alWarnings = alMetrics.warnings;
			alCounters = alMetrics.counters;
			alTimers = alMetrics.timers;
		}
		
		if (opUserEmail == null) {
			log("ERROR", "No OpenPages User email address passed in request");
		} else {
			log("Sending status email to " + opUserEmail);
			sendEmail(opUserEmail, requestID, workEntry, operation, accounts, alCounters, alErrors, alWarnings, alTimers, "In Progress");
		}
		
		nextStatus = java.lang.System.currentTimeMillis() + (statusInterval * 60 * 1000);
		log("DEBUG", "Next email dispatched at " + system.formatDate(new java.util.Date(nextStatus), "HH:mm:ss.SSS"));
	}
	
	return nextStatus;
}]]></parameter>
    </Script>
</MetamergeConfig>